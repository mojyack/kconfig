#!/usr/bin/env python3
# usage: driver-analyzer /path/to/linux relative/path/to/dts

import sys
import os
import re
import subprocess

compatibles_cache_file = "compatibles-cache.txt"


def extract_compatibles_from_source(file, rules):
    ret = []
    try:
        src = open(file).read()
    except UnicodeDecodeError:
        return []
    for rule in rules:
        pattern = rule[0]
        extract = rule[1]
        for match in re.findall(pattern, src):
            match = match.replace("\t", " ")
            match = match.replace('",', '"')
            ret.append(extract(match))
    return ret


# compatibles: list of list([0] = source file path, [1:] = compatible strings)


def list_compatibles(dir):
    ret = []
    rules = [
        [
            re.compile(r'\.compatible\s*=\s*".*"'),
            lambda match: [x for x in match.split(" ") if x][2][1:-1],
        ],
        [
            re.compile(r'of_get_compatible_child(.*,.*")'),
            lambda match: match.split(" ")[-1][1:-1],
        ],
        [
            re.compile(r'of_device_is_compatible(.*,.*")'),
            lambda match: match.split(" ")[-1][1:-1],
        ],
        [
            re.compile(r'IRQCHIP_MATCH(.*,.*")'),
            lambda match: match.split(" ")[-1][2:-1],
        ],
        [
            re.compile(r"of_find_compatible_node(.*,.*,.*)"),
            lambda match: match.split(" ")[-1][1:-3],
        ],
    ]

    for cwd, dirs, files in os.walk(dir):
        for file in files:
            if not file.endswith(".c"):
                continue
            path = cwd + "/" + file
            matches = extract_compatibles_from_source(path, rules)
            if len(matches) == 0:
                continue
            ret.append([path] + matches)
    return ret


def regex_test():
    file = "drivers/counter/stm32-timer-cnt.c"
    file = "drivers/usb/dwc3/dwc3-qcom.c"
    file = "drivers/mmc/host/sdhci-msm.c"
    file = "drivers/phy/qualcomm/phy-qcom-qusb2.c"
    file = "drivers/of/platform.c"
    file = "drivers/power/supply/qcom_pmi8998_charger.c"
    # file = "drivers/counter/ti-ecap-capture.c"
    # file = "sound/soc/qcom/qdsp6/q6afe.c"
    # pattern = re.compile(r'\.compatible\s*=\s*".*"')
    # pattern = re.compile(r"of_device_is_compatible(.*,.*\")")
    file = "drivers/irqchip/qcom-pdc.c"
    pattern = re.compile(r'IRQCHIP_MATCH(.*,.*")')
    file = "drivers/remoteproc/qcom_pil_info.c"
    pattern = re.compile(r"of_find_compatible_node(.*,.*,.*)")
    ret = []
    src = open(file).read()
    for match in re.findall(pattern, src):
        match = match.replace("\t", " ")
        match = match.replace('",', '"')
        print(match)
        # ret.append([x for x in match.split(" ") if x][2][1:-1])
        ret.append(match.split(" ")[-1][1:-3])
    return ret


# print(regex_test())
# exit(0)


def dump_compatibles(compatibles):
    file = open(compatibles_cache_file, "w")
    for compatible in compatibles:
        for elm in compatible:
            file.write(elm)
            file.write(" ")
        file.write("\n")


def load_compatibles():
    ret = []
    text = open(compatibles_cache_file).read()
    for line in text.split("\n"):
        if len(line) > 0:
            ret.append(line.strip().split(" "))
    return ret


def compile_dts(src, dts):
    args = "clang -x assembler-with-cpp -nostdinc -E -P".split(" ") + [
        f"-I{src}/include",
        f"{src}/{dts}",
    ]
    # print(args)

    result = subprocess.run(
        args,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
    )
    stdout = result.stdout.decode("utf-8")
    if result.returncode != 0:
        print("cc error", result.returncode, stdout)
        exit(1)
    return stdout


def extract_devices_from_dts(dts):
    found = set()
    ret = []
    for line in dts.split("\n"):
        if not "compatible " in line:
            continue

        compatibles = [e[1:-2] for e in line.strip().split(" ")[2:]]
        key = "".join(compatibles)
        if not key in found:
            found.add(key)
            ret.append(compatibles)

    return ret


# returns (code,list)
# code: 0 = ok, 1 = makefile not found, 2 = possible result
def find_corresponding_config(file):
    makefile_path = os.path.dirname(file) + "/Makefile"
    if not os.path.exists(makefile_path):
        return (0, [])

    ret = []
    name = os.path.basename(file)[:-2] + ".o"
    makefile = open(makefile_path).read()
    for line in makefile.split("\n"):
        if not name in line or not "CONFIG_" in line:
            continue
        config = re.search("CONFIG_[0-9A-Z_]*", line)
        ret.append(config.group())

    if len(ret) > 0:
        return (1, ret)

    for match in re.findall(re.compile("CONFIG_[0-9A-Z_]*"), makefile):
        ret.append(match)
    return (2, ret)


src = sys.argv[1]
dts = sys.argv[2]

if not os.path.exists(compatibles_cache_file):
    print("enumerating drivers")
    compatibles = list_compatibles(f"{src}/drivers") + list_compatibles(f"{src}/sound")
    dump_compatibles(compatibles)
else:
    print("using cache")
    compatibles = load_compatibles()

dts = compile_dts(src, dts)
open(os.path.basename(sys.argv[2]), "w").write(dts)
devices = extract_devices_from_dts(dts)

found_sources = []  # list of [device, files...]
missing_drivers = []

for device in devices:
    sources = [device]
    for device_compatible in device:
        for driver_compatibles in compatibles:
            # exclude driver_compatibles[0] from search, since [0] is a file path
            if device_compatible in driver_compatibles[1:]:
                sources.append(driver_compatibles[0])

    if len(sources) >= 2:
        found_sources.append(sources)
    else:
        missing_drivers.append(device)

print(f"devices without driver({len(missing_drivers)}):")
for driver in missing_drivers:
    print(f"    {driver}")

print(f"found source files({len(found_sources)}):")
for source in found_sources:
    device = source[0]
    files = source[1:]
    print(f"    {device}")
    for file in files:
        rel = file[len(src) + 1 :]
        print(f"        {rel}")
        code, configs = find_corresponding_config(file)

        match code:
            case 0:
                print("            makefile not found")
            case 1:
                if len(configs) == 1:
                    print("            exactly", configs[0])
                else:
                    for config in configs:
                        print("            possibly", config)
            case 2:
                if len(configs) == 1:
                    print("            possibly", configs[0])
                else:
                    print("            cannot find exact match")
